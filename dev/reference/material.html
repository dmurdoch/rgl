<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Get or set material properties — material3d • rgl</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Get or set material properties — material3d"><meta property="og:description" content="Get or set material properties for geometry appearance."><meta name="robots" content="noindex"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- dependencies from examples --><script src="libs/htmlwidgets-1.6.1/htmlwidgets.js"></script><script src="libs/rglWebGL-binding-1.0.4/rglWebGL.js"></script><link href="libs/rglwidgetClass-1.0.4/rgl.css" rel="stylesheet"><script src="libs/rglwidgetClass-1.0.4/rglClass.min.js"></script><!--html_preserve--><script type="text/plain" id="rgl-vertex-shader">
#line 2 1
// File 1 is the vertex shader
#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#endif

attribute vec3 aPos;
attribute vec4 aCol;
uniform mat4 mvMatrix;
uniform mat4 prMatrix;
varying vec4 vCol;
varying vec4 vPosition;

#ifdef NEEDS_VNORMAL
attribute vec3 aNorm;
uniform mat4 normMatrix;
varying vec4 vNormal;
#endif

#if defined(HAS_TEXTURE) || defined (IS_TEXT)
attribute vec2 aTexcoord;
varying vec2 vTexcoord;
#endif

#ifdef FIXED_SIZE
uniform vec3 textScale;
#endif

#ifdef FIXED_QUADS
attribute vec3 aOfs;
#endif

#ifdef IS_TWOSIDED
#ifdef HAS_NORMALS
varying float normz;
uniform mat4 invPrMatrix;
#else
attribute vec3 aPos1;
attribute vec3 aPos2;
varying float normz;
#endif
#endif // IS_TWOSIDED

#ifdef FAT_LINES
attribute vec3 aNext;
attribute vec2 aPoint;
varying vec2 vPoint;
varying float vLength;
uniform float uAspect;
uniform float uLwd;
#endif


void main(void) {
  
#ifndef IS_BRUSH
#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG)
  vPosition = mvMatrix * vec4(aPos, 1.);
#endif
  
#ifndef FIXED_QUADS
  gl_Position = prMatrix * vPosition;
#endif
#endif // !IS_BRUSH
  
#ifdef IS_POINTS
  gl_PointSize = POINTSIZE;
#endif
  
  vCol = aCol;
  
#ifdef NEEDS_VNORMAL
  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));
#endif
  
#ifdef IS_TWOSIDED
#ifdef HAS_NORMALS
  /* normz should be calculated *after* projection */
  normz = (invPrMatrix*vNormal).z;
#else
  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));
  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;
  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));
  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;
  normz = pos1.x*pos2.y - pos1.y*pos2.x;
#endif
#endif // IS_TWOSIDED
  
#ifdef NEEDS_VNORMAL
  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);
#endif
  
#if defined(HAS_TEXTURE) || defined(IS_TEXT)
  vTexcoord = aTexcoord;
#endif
  
#if defined(FIXED_SIZE) && !defined(ROTATING)
  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);
  pos = pos/pos.w;
  gl_Position = pos + vec4(aOfs*textScale, 0.);
#endif
  
#if defined(IS_SPRITES) && !defined(FIXED_SIZE)
  vec4 pos = mvMatrix * vec4(aPos, 1.);
  pos = pos/pos.w + vec4(aOfs,  0.);
  gl_Position = prMatrix*pos;
#endif
  
#ifdef FAT_LINES
  /* This code was inspired by Matt Deslauriers' code in 
   https://mattdesl.svbtle.com/drawing-lines-is-hard */
  vec2 aspectVec = vec2(uAspect, 1.0);
  mat4 projViewModel = prMatrix * mvMatrix;
  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);
  currentProjected = currentProjected/currentProjected.w;
  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);
  vec2 currentScreen = currentProjected.xy * aspectVec;
  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;
  float len = uLwd;
  vec2 dir = vec2(1.0, 0.0);
  vPoint = aPoint;
  vLength = length(nextScreen - currentScreen)/2.0;
  vLength = vLength/(vLength + len);
  if (vLength > 0.0) {
    dir = normalize(nextScreen - currentScreen);
  }
  vec2 normal = vec2(-dir.y, dir.x);
  dir.x /= uAspect;
  normal.x /= uAspect;
  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);
  gl_Position = currentProjected + offset;
#endif
  
#ifdef IS_BRUSH
  gl_Position = vec4(aPos, 1.);
#endif
}
</script><script type="text/plain" id="rgl-fragment-shader">
#line 2 2
// File 2 is the fragment shader
#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#endif
varying vec4 vCol; // carries alpha
varying vec4 vPosition;
#if defined(HAS_TEXTURE) || defined (IS_TEXT)
varying vec2 vTexcoord;
uniform sampler2D uSampler;
#endif

#ifdef HAS_FOG
uniform int uFogMode;
uniform vec3 uFogColor;
uniform vec4 uFogParms;
#endif

#if defined(IS_LIT) && !defined(FIXED_QUADS)
varying vec4 vNormal;
#endif

#if NCLIPPLANES > 0
uniform vec4 vClipplane[NCLIPPLANES];
#endif

#if NLIGHTS > 0
uniform mat4 mvMatrix;
#endif

#ifdef IS_LIT
uniform vec3 emission;
uniform float shininess;
#if NLIGHTS > 0
uniform vec3 ambient[NLIGHTS];
uniform vec3 specular[NLIGHTS]; // light*material
uniform vec3 diffuse[NLIGHTS];
uniform vec3 lightDir[NLIGHTS];
uniform bool viewpoint[NLIGHTS];
uniform bool finite[NLIGHTS];
#endif
#endif // IS_LIT

#ifdef IS_TWOSIDED
uniform bool front;
varying float normz;
#endif

#ifdef FAT_LINES
varying vec2 vPoint;
varying float vLength;
#endif

void main(void) {
  vec4 fragColor;
#ifdef FAT_LINES
  vec2 point = vPoint;
  bool neg = point.y < 0.0;
  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :
                 -(point.y - vLength)/(1.0 - vLength);
#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)
  if (neg && length(point) <= 1.0) discard;
#endif
  point.y = min(point.y, 0.0);
  if (length(point) > 1.0) discard;
#endif // FAT_LINES
  
#ifdef ROUND_POINTS
  vec2 coord = gl_PointCoord - vec2(0.5);
  if (length(coord) > 0.5) discard;
#endif
  
#if NCLIPPLANES > 0
  for (int i = 0; i < NCLIPPLANES; i++)
    if (dot(vPosition, vClipplane[i]) < 0.0) discard;
#endif
    
#ifdef FIXED_QUADS
    vec3 n = vec3(0., 0., 1.);
#elif defined(IS_LIT)
    vec3 n = normalize(vNormal.xyz);
#endif
    
#ifdef IS_TWOSIDED
    if ((normz <= 0.) != front) discard;
#endif
    
#ifdef IS_LIT
    vec3 eye = normalize(-vPosition.xyz/vPosition.w);
    vec3 lightdir;
    vec4 colDiff;
    vec3 halfVec;
    vec4 lighteffect = vec4(emission, 0.);
    vec3 col;
    float nDotL;
#ifdef FIXED_QUADS
    n = -faceforward(n, n, eye);
#endif
    
#if NLIGHTS > 0
    for (int i=0;i<NLIGHTS;i++) {
      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);
      lightdir = lightDir[i];
      if (!viewpoint[i])
        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;
      if (!finite[i]) {
        halfVec = normalize(lightdir + eye);
      } else {
        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);
        halfVec = normalize(lightdir + eye);
      }
      col = ambient[i];
      nDotL = dot(n, lightdir);
      col = col + max(nDotL, 0.) * colDiff.rgb;
      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];
      lighteffect = lighteffect + vec4(col, colDiff.a);
    }
#endif
    
#else // not IS_LIT
    vec4 colDiff = vCol;
    vec4 lighteffect = colDiff;
#endif
    
#ifdef IS_TEXT
    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);
#endif
    
#ifdef HAS_TEXTURE
#ifdef TEXTURE_rgb
    vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);
#endif
    
#ifdef TEXTURE_rgba
    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);
#endif
    
#ifdef TEXTURE_alpha
    vec4 textureColor = texture2D(uSampler, vTexcoord);
    float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;
    textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);
#endif
    
#ifdef TEXTURE_luminance
    vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);
#endif
    
#ifdef TEXTURE_luminance_alpha
    vec4 textureColor = texture2D(uSampler, vTexcoord);
    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;
    textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);
#endif
    
    fragColor = textureColor;

#elif defined(IS_TEXT)
    if (textureColor.a < 0.1)
      discard;
    else
      fragColor = textureColor;
#else
    fragColor = lighteffect;
#endif // HAS_TEXTURE
    
#ifdef HAS_FOG
    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))
    // In Exp and Exp2: use density = density/far
    // fogF will be the proportion of fog
    // Initialize it to the linear value
    float fogF;
    if (uFogMode > 0) {
      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);
      if (uFogMode > 1)
        fogF = mix(uFogParms.w, 1.0, fogF);
      fogF = fogF*uFogParms.z;
      if (uFogMode == 2)
        fogF = 1.0 - exp(-fogF);
      // Docs are wrong: use (density*c)^2, not density*c^2
      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58
      else if (uFogMode == 3)
        fogF = 1.0 - exp(-fogF*fogF);
      fogF = clamp(fogF, 0.0, 1.0);
      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);
    } else gl_FragColor = fragColor;
#else
    gl_FragColor = fragColor;
#endif // HAS_FOG
    
}
</script><!--/html_preserve--><script src="libs/CanvasMatrix4-1.0.4/CanvasMatrix.min.js"></script></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rgl</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="In-development version">1.0.4</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../articles/rgl.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../rglClass/index.html">Javascript</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/WebGL.html">User Interaction in WebGL (updated)</a>
    </li>
    <li>
      <a href="../articles/deprecation.html">Deprecating the `rgl.*` interface</a>
    </li>
    <li>
      <a href="../articles/pkgdown.html">Using RGL in pkgdown web sites</a>
    </li>
    <li>
      <a href="../articles/transparency.html">A Note on Transparency</a>
    </li>
  </ul></li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/dmurdoch/rgl/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Get or set material properties</h1>
    
    <div class="hidden name"><code>material.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Get or set material properties for geometry appearance.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">material3d</span><span class="op">(</span><span class="va">...</span>, id <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span>
<span></span>
<span><span class="va">rgl.material.names</span></span>
<span><span class="va">rgl.material.readonly</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>...</dt>
<dd><p>Material properties to set or query.</p></dd>

  <dt>id</dt>
<dd><p>the <span class="pkg">rgl</span> id of an object to query, or <code>NULL</code>
  to query or set the defaults.</p></dd>

</dl></div>
    <div id="details">
    <h2>Details</h2>
    <p>In an <span class="pkg">rgl</span> scene, each object has “material properties” that control how it is rendered and (in the case of <code>tag</code>) 
that can be used to store a 
label or other information.  <code>material3d</code> sets defaults
for these properties and queries the defaults or specific
values for an individual object.</p>
<p>To set values, use <code>name = value</code> settings, e.g.
<code>material3d(color = "red")</code>.  To query values, 
specify the property or properties in a character vector,
e.g. <code>material3d("color")</code>.</p>
<p>Only one side at a time can be culled.</p>
<p>The <code>material</code> member of the <code><a href="open3d.html">r3dDefaults</a></code> list may be used to 
set default values for material properties.</p>
    </div>
    <div id="material-properties">
    <h2>Material Properties</h2>
    

<p>The <code>rgl.material.names</code> variable contains the
full list of material names.
The following read-write material properties control
the appearance
of objects in an <span class="pkg">rgl</span> scene.</p>
<dl><dt>color</dt>
<dd><p>vector of R color characters. Represents the diffuse component in case of lighting calculation (lit = TRUE),
    otherwise it describes the solid color characteristics.</p></dd>

  <dt>lit</dt>
<dd><p>logical, specifying if lighting calculation should take place on geometry</p></dd>

  <dt>ambient, specular, emission, shininess</dt>
<dd><p>properties for lighting calculation. ambient, specular, emission are R color character string values; shininess represents a
    numerical.</p></dd>

  <dt>alpha</dt>
<dd><p>vector of alpha values between 0.0 (fully transparent) .. 1.0 (opaque).</p></dd>

  <dt>smooth</dt>
<dd><p>logical, specifying whether smooth shading or flat shading
    should be used.  For smooth shading, Gouraud shading is
    used in <span class="pkg">rgl</span> windows, while Phong shading is used 
    in WebGL.</p></dd>

  <dt>texture</dt>
<dd><p>path to a texture image file. Supported formats: png.</p></dd>

  <dt>textype</dt>
<dd><p>specifies what is defined with the pixmap</p><dl><dt>"alpha"</dt>
<dd><p>alpha values</p></dd>

      <dt>"luminance"</dt>
<dd><p>luminance</p></dd>

      <dt>"luminance.alpha"</dt>
<dd><p>luminance and alpha</p></dd>

      <dt>"rgb"</dt>
<dd><p>color</p></dd>

      <dt>"rgba"</dt>
<dd><p>color and alpha texture</p></dd>

    
</dl><p></p></dd>

  <dt>texmipmap</dt>
<dd><p>Logical, specifies if the texture should be mipmapped.</p></dd>

  <dt>texmagfilter</dt>
<dd><p>specifies the magnification filtering type (sorted by ascending quality):</p><dl><dt>"nearest"</dt>
<dd><p>texel nearest to the center of the pixel</p></dd>

      <dt>"linear"</dt>
<dd><p>weighted linear average of a 2x2 array of texels</p></dd>

    
</dl><p></p></dd>

  <dt>texminfilter</dt>
<dd><p>specifies the minification filtering type (sorted by ascending quality):</p><dl><dt>"nearest"</dt>
<dd><p>texel nearest to the center of the pixel</p></dd>

      <dt>"linear"</dt>
<dd><p>weighted linear average of a 2x2 array of texels</p></dd>

      <dt>"nearest.mipmap.nearest"</dt>
<dd><p>low quality mipmapping</p></dd>

      <dt>"nearest.mipmap.linear"</dt>
<dd><p>medium quality mipmapping</p></dd>

      <dt>"linear.mipmap.nearest"</dt>
<dd><p>medium quality mipmapping</p></dd>

      <dt>"linear.mipmap.linear"</dt>
<dd><p>high quality mipmapping</p></dd>

    
</dl><p></p></dd>

  <dt>texenvmap</dt>
<dd><p>logical, specifies if auto-generated texture coordinates for environment-mapping 
    should be performed on geometry.</p></dd>

  <dt>front, back</dt>
<dd><p>Determines the polygon mode for the specified side:</p><dl><dt>"filled"</dt>
<dd><p>filled polygon</p></dd>

      <dt>"lines"</dt>
<dd><p>wireframed polygon</p></dd>

      <dt>"points"</dt>
<dd><p>point polygon</p></dd>

      <dt>"culled"</dt>
<dd><p>culled (hidden) polygon</p></dd>

    
</dl><p></p></dd>

  <dt>size</dt>
<dd><p>numeric, specifying the size of points in pixels</p></dd>

  <dt>lwd</dt>
<dd><p>numeric, specifying the line width in pixels</p></dd>

  <dt>fog</dt>
<dd><p>logical, specifying if fog effect should be applied on the corresponding shape.  Fog type is set in <code><a href="bg.html">bg3d</a></code>.</p></dd>

  <dt>point_antialias, line_antialias</dt>
<dd><p>logical, specifying if points should be round and lines 
     should be antialiased, but see Note below.</p></dd>

  <dt>depth_mask</dt>
<dd><p>logical, specifying whether the object's depth
     should be stored.</p></dd>

  <dt>depth_test</dt>
<dd><p>Determines which depth test is used to see if this
     object is visible, depending on its apparent depth in the scene
     compared to the stored depth. Possible values are <code>"never"</code>,
     <code>"less"</code> (the default), <code>"equal"</code>, <code>"lequal"</code>
     (less than or equal), <code>"greater"</code>, <code>"notequal"</code>,
     <code>"gequal"</code> (greater than or equal), <code>"always"</code>.</p></dd>

  <dt>polygon_offset</dt>
<dd><p>A one or two element
vector giving the <samp>factor</samp> and <samp>units</samp> values
to use in a <code>glPolygonOffset()</code> call in OpenGL.  If
only one value is given, it is used for both elements.
The <samp>units</samp> value is added to the depth of all pixels in
a filled polygon,
and the <samp>factor</samp> value is multiplied by an estimate of
the slope of the polygon and then added to the depth.  Positive values “push” polygons back slightly for the purpose
of depth testing, to allow points, lines or other polygons
to be drawn on the surface without being obscured due 
to rounding error.  Negative values pull the object forward.
A typical value to use is <code>1</code> (which
is automatically expanded to <code>c(1,1)</code>).
If values are too large, objects which should be behind
the polygon will show through, and if values are too small,
the objects on the surface will be partially obscured. 
Experimentation may be needed to get it right.  The first
example in <code>?<a href="persp3d.html">persp3d</a></code> uses this property to add 
grid lines to a surface.</p></dd>

  <dt>margin, floating</dt>
<dd><p>Used mainly for text to
  draw annotations in the margins, but supported by
  most kinds of objects:  see <code><a href="axes3d.html">mtext3d</a></code>.</p></dd>

  <dt>tag</dt>
<dd><p>A length 1 string value.  These
  may be used to identify objects, or encode other meta
  data about the object.</p></dd>

  <dt>blend</dt>
<dd><p>Two string values from the list below
  describing how transparent objects are blended with
  colors behind them.
  The first determines the coefficient applied to the 
  color of the current object (the source); the second determines
  the coefficient applied to the existing color 
  (the destination). The resulting
  color will be the sum of the two resulting colors.
  The allowed strings
  correspond to OpenGL constants:</p><dl><dt>"zero"</dt>
<dd><p>Zero; color has no effect.</p></dd>

  <dt>"one"</dt>
<dd><p>One; color is added to the other term.</p></dd>

  <dt>"src_color", "one_minus_src_color"</dt>
<dd><p>Multiply by source color or its opposite.</p></dd>

  <dt>"dst_color", "one_minus_dst_color"</dt>
<dd><p>Multiply by destination color or its opposite.</p></dd>

  <dt>"src_alpha", "one_minus_src_alpha"</dt>
<dd><p>Multiply by
source alpha or its opposite.  Default values.</p></dd>

  <dt>"dst_alpha", "one_minus_dst_alpha"</dt>
<dd><p>Multiply by
destination alpha or its opposite.</p></dd>

  <dt>"constant_color", "one_minus_constant_color",
  "constant_alpha", "one_minus_constant_alpha",
  "src_alpha_saturate"</dt>
<dd><p>These are allowed, but to be useful
  they require other settings which <span class="pkg">rgl</span> doesn't
  support.</p></dd>

  
</dl><p></p></dd>

  <dt>col</dt>
<dd><p>An allowed abbreviation of <code>color</code>.</p></dd>


</dl><p>The <code>rgl.material.readonly</code> variable contains
the subset of material properties that are read-only
so they can be queried
but not set.
Currently there is only one:</p>
<dl><dt>isTransparent</dt>
<dd><p>Is the current color transparent?</p></dd>


</dl></div>
    <div id="value">
    <h2>Value</h2>
    

<p><code>material3d()</code> returns values similarly
to <code><a href="par3d.html">par3d</a></code>:
When setting properties, it returns the previous values
invisibly in a named list.  When querying multiple values, a
named list is returned. When a single value is queried it is
returned directly.</p>
    </div>
    <div id="display-of-objects">
    <h2>Display of objects</h2>
    
  
<p>Object display colors are determined as follows:</p><ul><li><p>If <code>lit = FALSE</code>, an element of the <code>color</code> vector property is displayed without modification.  See documentation for individual objects for information on which element is chosen.</p></li>
<li><p>If <code>lit = TRUE</code>, the color is determined as follows.</p><ol><li><p>The color is set to the <code>emission</code> property
of the object.</p></li>
<li><p>For each defined light, the following are added:
</p><ul><li><p>the product of the <code>ambient</code> color
of the light and the <code>ambient</code> color of the object is added.</p></li>
<li><p>the <code>color</code> of the
object is multiplied by the <code>diffuse</code> color
of the light and by a constant depending on
the angle between the surface and the direction to 
the light, and added.</p></li>
<li><p>the <code>specular</code> color of the object
is multiplied by the <code>specular</code> color of the 
light and a constant depending on the <code>shininess</code>
of the object and the direction to the light, and
added.  The <code>shininess</code> property mainly
determines the size of the shiny highlight; adjust
one or both of the <code>specular</code> colors to change
its brightness.</p></li>
</ul></li>
</ol></li>
</ul><p>If <code>point_antialias</code> is <code>TRUE</code>, points will be drawn as circles in WebGL; otherwise, they
will be drawn as squares.  Within R, the behaviour depends
on your graphics hardware:  for example, I see circles for 
both settings on my laptop.</p>
<p>Within R, lines tend to appear heavier with <code>line_antialias == TRUE</code>.  There's no difference at all
in WebGL.</p>
    </div>
    <div id="see-also">
    <h2>See also</h2>
    <div class="dont-index"><p><code><a href="bbox.html">bbox3d</a></code>,
<code><a href="bg.html">bg3d</a></code>,
<code><a href="light.html">light3d</a></code></p></div>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="va">save</span> <span class="op">&lt;-</span> <span class="fu">material3d</span><span class="op">(</span><span class="st">"color"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">material3d</span><span class="op">(</span>color <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">material3d</span><span class="op">(</span><span class="st">"color"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "#FF0000"</span>
<span class="r-in"><span><span class="fu">material3d</span><span class="op">(</span>color <span class="op">=</span> <span class="va">save</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># this illustrates the effect of depth_test</span></span></span>
<span class="r-in"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span>; <span class="va">xmid</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">1</span>, <span class="fl">3</span><span class="op">)</span>; <span class="va">ymid</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">z</span> <span class="op">&lt;-</span> <span class="fl">1</span></span></span>
<span class="r-in"><span><span class="fu"><a href="open3d.html">open3d</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">tests</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"never"</span>, <span class="st">"less"</span>, <span class="st">"equal"</span>, <span class="st">"lequal"</span>, <span class="st">"greater"</span>, </span></span>
<span class="r-in"><span>                  <span class="st">"notequal"</span>, <span class="st">"gequal"</span>, <span class="st">"always"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">8</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="primitives.html">triangles3d</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">z</span> <span class="op">+</span> <span class="va">i</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/grDevices/palettes.html" class="external-link">heat.colors</a></span><span class="op">(</span><span class="fl">8</span><span class="op">)</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="texts.html">texts3d</a></span><span class="op">(</span><span class="va">xmid</span>, <span class="va">ymid</span>, <span class="va">z</span> <span class="op">+</span> <span class="va">i</span>, <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="va">i</span>, <span class="va">tests</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, sep <span class="op">=</span> <span class="st">". "</span><span class="op">)</span>, depth_test <span class="op">=</span> <span class="va">tests</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span> </span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
<span class="r-in"><span><span class="fu"><a href="rglIds.html">highlevel</a></span><span class="op">(</span><span class="op">)</span>  <span class="co"># To trigger display</span></span></span>
<div id="rgl42062" style="width:480px;height:480px;" class="rglWebGL html-widget "></div>
<script type="application/json" data-for="rgl42062">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":842,"objects":{"848":{"id":848,"type":"triangles","material":{},"vertices":"0","colors":"2","centers":"3","normals":"1","ignoreExtent":false,"flags":32771},"849":{"id":849,"type":"text","material":{"lit":false,"depth_test":"never"},"vertices":"4","colors":"5","texts":[["1. never"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"6","family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":33808},"850":{"id":850,"type":"triangles","material":{},"vertices":"7","colors":"9","centers":"10","normals":"8","ignoreExtent":false,"flags":32771},"851":{"id":851,"type":"text","material":{"lit":false},"vertices":"11","colors":"12","texts":[["2. less"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"13","family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":33808},"852":{"id":852,"type":"triangles","material":{},"vertices":"14","colors":"16","centers":"17","normals":"15","ignoreExtent":false,"flags":32771},"853":{"id":853,"type":"text","material":{"lit":false,"depth_test":"equal"},"vertices":"18","colors":"19","texts":[["3. equal"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"20","family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":33808},"854":{"id":854,"type":"triangles","material":{},"vertices":"21","colors":"23","centers":"24","normals":"22","ignoreExtent":false,"flags":32771},"855":{"id":855,"type":"text","material":{"lit":false,"depth_test":"lequal"},"vertices":"25","colors":"26","texts":[["4. lequal"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"27","family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":33808},"856":{"id":856,"type":"triangles","material":{},"vertices":"28","colors":"30","centers":"31","normals":"29","ignoreExtent":false,"flags":32771},"857":{"id":857,"type":"text","material":{"lit":false,"depth_test":"greater"},"vertices":"32","colors":"33","texts":[["5. greater"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"34","family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":33808},"858":{"id":858,"type":"triangles","material":{},"vertices":"35","colors":"37","centers":"38","normals":"36","ignoreExtent":false,"flags":32771},"859":{"id":859,"type":"text","material":{"lit":false,"depth_test":"notequal"},"vertices":"39","colors":"40","texts":[["6. notequal"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"41","family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":33808},"860":{"id":860,"type":"triangles","material":{},"vertices":"42","colors":"44","centers":"45","normals":"43","ignoreExtent":false,"flags":32771},"861":{"id":861,"type":"text","material":{"lit":false,"depth_test":"gequal"},"vertices":"46","colors":"47","texts":[["7. gequal"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"48","family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":33808},"862":{"id":862,"type":"triangles","material":{},"vertices":"49","colors":"51","centers":"52","normals":"50","ignoreExtent":false,"flags":32771},"863":{"id":863,"type":"text","material":{"lit":false,"depth_test":"always"},"vertices":"53","colors":"54","texts":[["8. always"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"55","family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":33808},"846":{"id":846,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"845":{"id":845,"type":"background","material":{},"colors":"56","centers":"57","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"847":{"id":847,"type":"background","material":{"lit":false,"back":"lines"},"colors":"58","centers":"59","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"842":{"id":842,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":842,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,14.5851602554321],"modelMatrix":[[1,0,0,-2],[0,0.342020153999329,0.939692616462708,-5.85234928131104],[0,-0.939692616462708,0.342020153999329,-14.5868854522705],[0,0,0,1]],"projMatrix":[[3.73205089569092,0,0,0],[0,3.73205089569092,0,0],[0,0,-3.86370396614075,-52.577823638916],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.342020143325668,0.939692620785909,0],[0,-0.939692620785909,0.342020143325668,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[1,3,1,3,2,9],"windowRect":[0,0,256,256],"family":"sans","font":1,"cex":1,"useFreeType":true,"fontname":"NULL","maxClipPlanes":2147483647,"glVersion":"NA","activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,846],"subscenes":[],"flags":34067}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":480,"height":480,"buffer":{"accessors":[{"bufferView":0,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":2,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":3,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":5,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":6,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":7,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":8,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":10,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":11,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":12,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":14,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":15,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":16,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":17,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":18,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":19,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":20,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":21,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":22,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":23,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":24,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":25,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":26,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":27,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":28,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":29,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":30,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":31,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":32,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":33,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":34,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":35,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":36,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":37,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":38,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":39,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":40,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":41,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":42,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":43,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":44,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":45,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":46,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":47,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":48,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":49,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":50,"componentType":5121,"count":3,"type":"VEC3"},{"bufferView":51,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":52,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":53,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":54,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":55,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":56,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":57,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":58,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":59,"componentType":5121,"count":1,"type":"VEC3"}],"bufferViews":[{"buffer":0,"byteLength":9,"byteOffset":0},{"buffer":0,"byteLength":9,"byteOffset":9},{"buffer":0,"byteLength":4,"byteOffset":18},{"buffer":0,"byteLength":3,"byteOffset":22},{"buffer":0,"byteLength":3,"byteOffset":25},{"buffer":0,"byteLength":4,"byteOffset":28},{"buffer":0,"byteLength":3,"byteOffset":32},{"buffer":0,"byteLength":9,"byteOffset":35},{"buffer":0,"byteLength":9,"byteOffset":44},{"buffer":0,"byteLength":16,"byteOffset":56},{"buffer":0,"byteLength":3,"byteOffset":72},{"buffer":0,"byteLength":3,"byteOffset":75},{"buffer":0,"byteLength":4,"byteOffset":78},{"buffer":0,"byteLength":3,"byteOffset":82},{"buffer":0,"byteLength":9,"byteOffset":85},{"buffer":0,"byteLength":9,"byteOffset":94},{"buffer":0,"byteLength":16,"byteOffset":104},{"buffer":0,"byteLength":3,"byteOffset":120},{"buffer":0,"byteLength":3,"byteOffset":123},{"buffer":0,"byteLength":4,"byteOffset":126},{"buffer":0,"byteLength":3,"byteOffset":130},{"buffer":0,"byteLength":9,"byteOffset":133},{"buffer":0,"byteLength":9,"byteOffset":142},{"buffer":0,"byteLength":16,"byteOffset":152},{"buffer":0,"byteLength":3,"byteOffset":168},{"buffer":0,"byteLength":3,"byteOffset":171},{"buffer":0,"byteLength":4,"byteOffset":174},{"buffer":0,"byteLength":3,"byteOffset":178},{"buffer":0,"byteLength":9,"byteOffset":181},{"buffer":0,"byteLength":9,"byteOffset":190},{"buffer":0,"byteLength":16,"byteOffset":200},{"buffer":0,"byteLength":3,"byteOffset":216},{"buffer":0,"byteLength":3,"byteOffset":219},{"buffer":0,"byteLength":4,"byteOffset":222},{"buffer":0,"byteLength":3,"byteOffset":226},{"buffer":0,"byteLength":9,"byteOffset":229},{"buffer":0,"byteLength":9,"byteOffset":238},{"buffer":0,"byteLength":4,"byteOffset":247},{"buffer":0,"byteLength":3,"byteOffset":251},{"buffer":0,"byteLength":3,"byteOffset":254},{"buffer":0,"byteLength":4,"byteOffset":257},{"buffer":0,"byteLength":3,"byteOffset":261},{"buffer":0,"byteLength":9,"byteOffset":264},{"buffer":0,"byteLength":9,"byteOffset":273},{"buffer":0,"byteLength":16,"byteOffset":284},{"buffer":0,"byteLength":3,"byteOffset":300},{"buffer":0,"byteLength":3,"byteOffset":303},{"buffer":0,"byteLength":4,"byteOffset":306},{"buffer":0,"byteLength":3,"byteOffset":310},{"buffer":0,"byteLength":9,"byteOffset":313},{"buffer":0,"byteLength":9,"byteOffset":322},{"buffer":0,"byteLength":16,"byteOffset":332},{"buffer":0,"byteLength":3,"byteOffset":348},{"buffer":0,"byteLength":3,"byteOffset":351},{"buffer":0,"byteLength":4,"byteOffset":354},{"buffer":0,"byteLength":3,"byteOffset":358},{"buffer":0,"byteLength":16,"byteOffset":364},{"buffer":0,"byteLength":3,"byteOffset":380},{"buffer":0,"byteLength":4,"byteOffset":383},{"buffer":0,"byteLength":3,"byteOffset":387}],"buffers":[{"byteLength":390,"bytes":"AQICAgECAwMCAAABAAABAAABAQAAAQICAgICAgAAAAECAgIBAgMCAQMDAwMAAAEAAAEAAAEA\nAAAAAIA/zcxMPgAAAAAAAIA/AgIDAgIDAAAAAQICAwECBAIBBAMDBAAAAQAAAQAAAQAAAIA/\nzczMPgAAAAAAAIA/AgIEAgIEAAAAAQICBAECBQIBBQMDBQAAAQAAAQAAAQAAAIA/mpkZPwAA\nAAAAAIA/AgIFAgIFAAAAAQICBQECBgIBBgMDBgAAAQAAAQAAAQAAAIA/zcxMPwAAAAAAAIA/\nAgIGAgIGAAAAAQICBgECBwIBBwMDBwAAAQAAAQAAAQEBAAECAgcCAgcAAAABAgIHAQIIAgEI\nAwMIAAABAAABAAABAAAAAIA/AACAP4GAgD4AAIA/AgIIAgIIAAAAAQICCAECCQIBCQMDCQAA\nAQAAAQAAAQAAAIA/AACAP8C/Pz8AAIA/AgIJAgIJAAAAAQICCQAAAJmYmD6ZmJg+mZiYPgAA\ngD8AAAABAQEBAAAA"}]},"context":{"shiny":false,"rmarkdown":null},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n    \n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n#ifdef TEXTURE_rgb\n    vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);\n#endif\n    \n#ifdef TEXTURE_rgba\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef TEXTURE_alpha\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n    float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;\n    textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);\n#endif\n    \n#ifdef TEXTURE_luminance\n    vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);\n#endif\n    \n#ifdef TEXTURE_luminance_alpha\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n    textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);\n#endif\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script><span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># this illustrates additive blending</span></span></span>
<span class="r-in"><span><span class="fu"><a href="open3d.html">open3d</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="bg.html">bg3d</a></span><span class="op">(</span><span class="st">"darkgray"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">quad</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span><span class="op">)</span>, <span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="primitives.html">quads3d</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="fu"><a href="matrices.html">translate3d</a></span><span class="op">(</span><span class="va">quad</span>, <span class="op">-</span><span class="fl">0.5</span>, <span class="fl">0</span>, <span class="op">-</span><span class="fl">0.5</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              <span class="fu"><a href="matrices.html">translate3d</a></span><span class="op">(</span><span class="va">quad</span>, <span class="fl">0.5</span>,  <span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.5</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              <span class="fu"><a href="matrices.html">translate3d</a></span><span class="op">(</span><span class="va">quad</span>, <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span>, </span></span>
<span class="r-in"><span>        col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"red"</span>, <span class="st">"green"</span>, <span class="st">"blue"</span><span class="op">)</span>, each <span class="op">=</span> <span class="fl">4</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>        alpha <span class="op">=</span> <span class="fl">0.5</span>, </span></span>
<span class="r-in"><span>        blend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"src_alpha"</span>, <span class="st">"one"</span><span class="op">)</span><span class="op">)</span></span></span>
<div id="rgl60058" style="width:480px;height:480px;" class="rglWebGL html-widget "></div>
<script type="application/json" data-for="rgl60058">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":864,"objects":{"871":{"id":871,"type":"quads","material":{"alpha":[0.498039215803146,0.498039215803146,0.498039215803146,0.498039215803146,0.498039215803146,0.498039215803146,0.498039215803146,0.498039215803146,0.498039215803146,0.498039215803146,0.498039215803146,0.498039215803146],"isTransparent":true,"blend":["src_alpha","one"]},"vertices":"0","colors":"2","centers":"3","normals":"1","ignoreExtent":false,"flags":32811},"868":{"id":868,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"867":{"id":867,"type":"background","material":{},"colors":"4","centers":"5","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"869":{"id":869,"type":"background","material":{"lit":false,"back":"lines"},"colors":"6","centers":"7","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"870":{"id":870,"type":"background","material":{"lit":false,"back":"lines"},"colors":"8","centers":"9","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"864":{"id":864,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":864,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,8.42074680328369],"modelMatrix":[[1,0,0,0],[0,0.342020153999329,0.939692616462708,-0.513030230998993],[0,-0.939692616462708,0.342020153999329,-7.01120758056641],[0,0,0,1]],"projMatrix":[[3.73205089569092,0,0,0],[0,3.73205089569092,0,0],[0,0,-3.86370301246643,-30.3558177947998],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.342020143325668,0.939692620785909,0],[0,-0.939692620785909,0.342020143325668,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[-1.5,1.5,1,2,-1.5,1.5],"windowRect":[0,0,256,256],"family":"sans","font":1,"cex":1,"useFreeType":true,"fontname":"NULL","maxClipPlanes":2147483647,"glVersion":"NA","activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[870,871,868],"subscenes":[],"flags":33067}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":480,"height":480,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":1,"componentType":5120,"count":12,"type":"VEC3"},{"bufferView":2,"componentType":5121,"count":12,"type":"VEC4","normalized":true},{"bufferView":3,"componentType":5126,"count":3,"type":"VEC3"},{"bufferView":4,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":6,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":8,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":9,"componentType":5121,"count":1,"type":"VEC3"}],"bufferViews":[{"buffer":0,"byteLength":144,"byteOffset":0},{"buffer":0,"byteLength":36,"byteOffset":144},{"buffer":0,"byteLength":48,"byteOffset":180},{"buffer":0,"byteLength":36,"byteOffset":228},{"buffer":0,"byteLength":16,"byteOffset":264},{"buffer":0,"byteLength":3,"byteOffset":280},{"buffer":0,"byteLength":4,"byteOffset":283},{"buffer":0,"byteLength":3,"byteOffset":287},{"buffer":0,"byteLength":16,"byteOffset":292},{"buffer":0,"byteLength":3,"byteOffset":308}],"buffers":[{"byteLength":311,"bytes":"AADAvwAAgD8AAMC/AAAAPwAAgD8AAMC/AAAAPwAAgD8AAAA/AADAvwAAgD8AAAA/AAAAvwAA\nwD8AAMC/AADAPwAAwD8AAMC/AADAPwAAwD8AAAA/AAAAvwAAwD8AAAA/AACAvwAAAEAAAAC/\nAACAPwAAAEAAAAC/AACAPwAAAEAAAMA/AACAvwAAAEAAAMA/AP8AAP8AAP8AAP8AAP8AAP8A\nAP8AAP8AAP8AAP8AAP8AAP8A/wAAf/8AAH//AAB//wAAfwD/AH8A/wB/AP8AfwD/AH8AAP9/\nAAD/fwAA/38AAP9/AAAAvwAAgD8AAAC/AAAAPwAAwD8AAAC/AAAAAAAAAEAAAAA/mZiYPpmY\nmD6ZmJg+AACAPwAAAAEBAQEAAAAAAKqpKT+qqSk/qqkpPwAAgD8AAAA="}]},"context":{"shiny":false,"rmarkdown":null},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n    \n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n#ifdef TEXTURE_rgb\n    vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);\n#endif\n    \n#ifdef TEXTURE_rgba\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef TEXTURE_alpha\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n    float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;\n    textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);\n#endif\n    \n#ifdef TEXTURE_luminance\n    vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);\n#endif\n    \n#ifdef TEXTURE_luminance_alpha\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n    textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);\n#endif\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script></code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by <a href="https://github.com/dmurdoch" class="external-link">Duncan Murdoch</a>, <a href="http://neoscientists.org/~plex/" class="external-link">Daniel Adler</a>.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>

