---
title: "Notes on Shaders"
author: "Duncan Murdoch"
date: "2026-02-08"
output:
  rmarkdown::html_vignette:
    fig_height: 5
    fig_width: 5
    toc: yes
  pdf_document:
    fig_height: 5
    fig_width: 5
    toc: yes
  html_document:
    default
vignette: >
  %\VignetteIndexEntry{Notes on Shaders}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
if (!requireNamespace("rmarkdown", quietly = TRUE) ||
    !rmarkdown::pandoc_available("1.14")) {
  warning(call. = FALSE, "These vignettes assume rmarkdown and pandoc version 1.14.  These were not found. Older versions will not work.")
  knitr::knit_exit()
}
knitr::opts_chunk$set(echo = TRUE)
library(rgl)
options(rgl.useNULL = TRUE)
setupKnitr(autoprint = TRUE)
```

## Introduction

"Shaders" are programs written in GLSL that run on the GPU
to implement the details of rendering `rgl` scenes.  They were
introduced with OpenGL 2.0, and have been used in `rgl` for WebGL
rendering, and are now used in `rgl` when running within R
as well.


## Steps in shader use in R

This section describes the steps in setting up and using shaders.

- Setting `flags`.
  - done by `Shape::getShaderFlags`.
  - callers:  `PrimitiveSet::initialize -> Shape::initShader -> Shape::getShaderFlags`, `SphereSet::initialize -> Shape::initShader -> Shape::getShaderFlags`, `SpriteSet::initialize -> Shape::initShader -> Shape::getShaderFlags` and 
  `rgl::rgl_getShaderDefines` in the API.
- Compiling and linking the shaders.
  - done by `Shape::initShader`.
- Saving attribute and uniform locations.
  - done by `Shape::initShader` in several types.
- Creating the vertex and index buffers
  - done by `Shape::initShader`
- Putting attributes into the vertex buffer
  - done by `appendToBuffer` calls in various `initialize` methods.
- Putting indices into the index buffer
  - Not currently used. (FIXME:  delete it or use it where appropriate)
- Loading the vertex buffer data
  - done by `Shape::beginShader -> Shape::loadBuffers`
- Assigning values to the uniforms
  - done by `PrimitiveSet::drawBegin -> Shape::beginShader`
  - modified by `SphereSet::drawPrimitive` before each sphere.
- Enabling the attributes
  - done by `beginUse` in various array types, called from
    `drawBegin` in various types
- Setting state variables for material properties like 
  polygon offsets, etc.
  - done by `Material::beginUse`, from various `drawBegin` methods
  `BBoxDeco::render` and `Background::drawPrimitive`
- Do the drawing
  - done by `primitiveSet::drawAll`
  
For example, a PointSet object is created and drawn
in these steps:

  - The api function `rgl_primitive()` calls `PointSet()`
  to create the object.  `PointSet()` calls `PrimitiveSet()` which calls `Shape()`; these just store
  the data.
  - The `Subscene` has lists of objects that need to be 
  sorted (because of transparency) and others that don't.
  Drawing objects from each list is similar:  For each
  object, the `render()` method is called.
  - `PointSet` and `PrimitiveSet` have no `render()` method, so `Shape::render()` is used.
  - `Shape::render()` first calls `renderBegin()`, which does nothing for `PointSet` objects.  It then calls `draw()`, which goes to `PrimitiveSet::draw()`.
      - `PrimitiveSet::draw()` first calls `drawBegin()`, which goes to `PrimitiveSet::drawBegin()`.
          - `PrimitiveSet::drawBegin()` first calls `Shape::drawBegin()`.
              - `Shape::drawBegin()` just checks that we aren't nesting `drawBegin()` calls.
          - It then calls `Shape::beginShader()`.
              - `Shape::beginShader()` checks whether the
              object has been initialized, and if not, calls `initialize()` and `loadBuffers()`.
                  - `PrimitiveSet::initialize()` first calls `Shape::initialize()`.
                      - `Shape::initialize()` just marks the object as being initialized.
                  - It then calls `initShader()`, which goes to `Shape::initShader()`.
                      - `Shape::initShader()` compiles
                      and attaches the shaders, clears the buffers, and gets
                      the attribute and uniform
                      locations.
                  - Then it appends data to the buffers
                    and if necessary attaches the texture. 
              - `Shape::beginShader()` then uses the
              programs, binds the buffers and attaches the
              uniforms.
          - `PrimitiveSet::drawBegin()` then checks if it
          is drawing in the margin.  If so, it modifies
          the data to draw there.
          - Next, it calls `VertexArray::beginUse()` and
          `Material::beginUse()` which set some globals
          and attributes.
      - `PrimitiveSet::draw()` then calls `drawAll()`,
      which draws all the points, taking care to skip missings.
      - It then calls `drawEnd()`, which resets all the
      `drawBegin()` settings.
      
And that's it!
  
  
## Text

Previously `rgl` used the FTGL library to display text.  It's 
written for the fixed pipeline, so is not compatible with 
shader use. 

Currently text is handled similarly to the WebGL way.  
The text is drawn to a bitmap using the Cairo lib in 
the textraster
package, and the bitmap is used as a 
texture on a quad (which is drawn as two triangles, since
modern OpenGL does it that way).  

Limitation:  the
textraster package doesn't handle mixed fonts as well as
ragg does, and should probably be rewritten:  but I think 
ragg doesn't offer a C interface to draw to a raster, so it 
would be a big deal.

The bbox is also rewritten to be somewhat like WebGL.  It
is a container with several objects:  a set of quads for
the box, segments for the ticks, and text for the labels.

FTGL is completely gone now.